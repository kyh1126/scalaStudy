// src/main/scala/progscala2/introscala/upper2.sc

// object: 싱글턴 객체. 스칼라는 싱글턴 디자인 패턴을 언어의 1급 요소로 받아들였다. 스칼라 실행 환경(runtime)은 Upper 인스턴스를 오직 하나만
//         생성한다. 자바의 static 같이 다른 언어에서 클래스 수준의 멤버를 활용해야 하는 경우 스칼라에서는 object 를 사용한다.
//         (Upper 에 별도 상태가 들어있지 않기 때문에 인스턴스가 둘 이상 필요없다.)
//         스칼라는 모든 것이 객체여야 한다는 목표에 더 가까운 언어. 자바의 static 메서드나 필드는 특정 타입의 실제 인스턴스와 연관이 없다.
//         반면 object 는 어떤 타입의 유일한 인스턴스다.

// 싱글턴 패턴의 단점
// 1. 단위 테스트에서 테스트 더블로 대치하기 어렵다.
// 2. 모든 계산을 단일 인스턴스를 사용해서 수행하는 것은 스레드 안전성이나 성능 문제의 우려를 낳는다.
// -> 아무런 상태가 없고 객체와 외부 상호 작용 없을 경우 타당하다.

// 스칼라의 타입 추론
// 스칼라는 메서드의 반환 타입을 추론할 수 있지만 인자의 타입은 추론하지 못한다. 지역 타입 추론(local type inference) 알고리즘.
// 전체 프로그램을 대상으로 타입을 추론하지 않고, 일정 영역 내에서 지역적으로 작동.
// 따라서 인자가 지켜야 할 타입을 추론할 수는 없지만, 함수 본문 전체를 볼 수 있기 때문에 대부분의 경우 메서드가 반환하는 타입은 추론할 수 있다.
// (재귀 함수는 예외. 실행 영역이 본문을 벗어나기 때문. 따라서 재귀 함수의 반환 타입은 반드시 지정해야 한다)
// 때로 스칼라가 추론한 타입이 원하는 타입이 아닐 수도 있어, 반환 타입 명시하는 편을 더 권장.

object Upper {
  // 위치지정자(placeholder) _: 익명 변수처럼 작동. 익명 변수 타입도 추론.
  def upper(strings: String*) = strings.map(_.toUpperCase())
}

// 자바에서 정적 메서드를 호출하듯이 객체의 메서드를 직접 호출할 수 있다.
println(Upper.upper("Hello", "World!"))
