// src/main/scala/progscala2/introscala/upper1.sc

// 클래스: class 키워드로 시작. 전체 클래스 본문은 중괄호 사이에 위치.
//       클래스의 본문이 그 클래스의 주 생성자(primary constructor)다.
//       생성자가 매개 변수를 받아야 한다면 클래스 이름 뒤에 매개변수 목록을 추가할 수 있다.

// 메서드: def 키워드로 시작. 메서드 이름 다음엔 선택적으로 매개변수 목록이, 그 뒤에 선택적으로 반환 타입(return type)이 온다.
//       그 다음 등호(=)가 메소드 시그니처와 본문 사이에 온다. 스칼라는 메서드의 반환 타입을 추론할 수 있다. 등호를 사용하면 메서드가 매개변수를 받지 않는
//       경우 매개변수 목록을 생략할 수 있다. 등호는 값이나 함수가 더 깊이 연관된 개념이라는 함수형 프로그래밍의 원칙을 강조하기 위함이기도 하다.
//       스칼라는 메서드 본문이 단일 식으로 이뤄진 경우 중괄호 생략 허용한다.

// Seq: Set, Map 과 다르게 일정한 순서로 반복 가능한 추상적 컬렉션이다. 자바의 제네릭 타입과 마찬가지로 매개변수화한 타입(parameterized type)이다.
//      어떤 것의 시퀀스. 매개변수화한 타입을 지정할 때 자바는 <>를, 스칼라는 []를 사용한다.

// 람다: 자바 8에 추가된 익명 함수. 자바 8 이전에는 작업을 수행할 메서드를 하나만 정의한 인터페이스를 사용했다.(보통은 익명 내포 클래스로 구현하는 방식으로)
//      그렇게 어떤 외부 행동을 매개변수화해서 내부 동작에 전달하는 것을 어느 정도 비슷하게 할 수 있었다.

// 스칼라에서는 함수나 메서드의 가장 마지막 식이 반환값이 된다. return 키워드도 있지만 메서드 안에서만 사용 가능하며, 익명 함수 같은 곳에서는 사용할 수 없다.
// 실제로는 메서드에서도 return 을 사용하는 일이 드물다.

class Upper {
  // *: 가변 길이 매개변수 목록.
  def upper(strings: String*): Seq[String] = {
    // map: 함수 리터럴(function literal)을 인자로 받는다. 함수 리터럴은 '익명'함수다. 다른 언어에서는 람다, 클로저, 블록, 프록 등으로 불린다.
    strings.map(
      // 함수 리터럴
      (s:String) => s.toUpperCase()
    )
  }
}

// new Upper 는 새로운 인스턴스를 만든다. (주 생성자가 인자를 받지 않아 인자 목록 지정 x)
// val: 자바의 final 변수와 비슷하게 동작.
val up = new Upper
println(up.upper("Hello", "World!"))
